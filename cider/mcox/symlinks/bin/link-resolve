#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
'''
Resolve shortend URLs
'''
#
# Standard Imports
#
from __future__ import absolute_import, division, print_function, unicode_literals
import argparse
from datetime import date, datetime
import json
import logging
try:
    from pathlib import Path
except ModuleNotFoundError:
    from pathlib2 import Path
import os
import sys
try:
    from urllib.parse import urlparse
except ImportError:
     from urlparse import urlparse

#
# Non-standard imports
#
import requests


#
##############################################################################
#
# Global variables
#
DEFAULT_LOG_LEVEL = os.environ.get('PY_LOG_LEVEL', 'WARNING')

DESCRIPTION = "Resolve shortend URLs"
#
##############################################################################
#
# _clean_loggers()
#
def _clean_loggers():
    '''Remove existing logging handlers (mostly for Lambda)'''
    root = logging.getLogger()
    if root.handlers:
        for handler in root.handlers:
            root.removeHandler(handler)
    # try this here
    logging.basicConfig(format='%(asctime)s %(levelname)s:%(name)s.%(funcName)s:%(message)s',
                        level=getattr(logging, DEFAULT_LOG_LEVEL))

#
##############################################################################
#
# _get_logger()
#
def _get_logger():
    '''
    Reusable code to get the correct logger by name of current file

    Returns:
        logging.logger: Instance of logger for name of current file

    '''
    return logging.getLogger(Path(__file__).resolve().name)
#
##############################################################################
#
# _json_dump() - Little output to DRY
#
def _json_dump(the_thing, pretty=False):
    '''
    Reusable JSON dumping code

    Returns:
        str: JSON string representation suitable for print'ing
    '''
    output = None
    if pretty:
        output = json.dumps(the_thing, default=_json_serial, sort_keys=True, indent=4,
                            separators=(',', ': '))
    else:
        output = json.dumps(the_thing, default=_json_serial)
    return output

def _json_serial(obj):
    '''JSON serializer for objects not serializable by default json code'''

    if isinstance(obj, (datetime, date)):
        return obj.isoformat()
    raise TypeError("Type %s not serializable" % type(obj))
#
#
##############################################################################
#
# handle_arguments()
#
def handle_arguments():
    '''
    Handle CLI arguments

    Returns:
        parser.Namespace: Representation of the parsed arguments
    '''
    #
    # Handle CLI args
    #
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    # add arguments
    parser.add_argument('url', type=str, help='The URL to resolve')
    parser.add_argument('-l', '--log-level', action='store', required=False,
                        choices=["debug", "info", "warning", "error", "critical"],
                        default=DEFAULT_LOG_LEVEL,
                        help='Logging verbosity. Default: %(default)s')

    return parser.parse_args()
#
#
##############################################################################
#
# main()
#
def main():
    '''Do the work'''

    args = handle_arguments()

    # Configure logging
    logging.basicConfig(format='%(asctime)s %(levelname)s:%(name)s.%(funcName)s:%(message)s',
                        level=getattr(logging, args.log_level.upper()))

    logger = _get_logger()

    logger.info("Log level is '%s'", args.log_level.upper())

    req = requests.get(args.url, allow_redirects=False)

    if req.status_code == 301:
        redirect = req.headers.get('Location')
        parsed = urlparse(redirect)
        path = parsed.path
        if 'ref=' in parsed.path:
            path = '/'.join(parsed.path.split('/')[:-1])
        print(''.join([parsed.netloc, path]))
    else:
        parsed = urlparse(redirect)
        path = parsed.path
        print(''.join([parsed.netloc, path]))
#
##############################################################################
#
# Call the main function
#
if __name__ == '__main__':
    main()
